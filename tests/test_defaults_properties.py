"""Property-based tests for Smart Defaults Engine.

**Property 3: Configuration Generation Round-Trip**
**Validates: Requirements 1.5, 11.1, 11.6**

Tests that:
- Generated configuration is parseable by the existing Config_Parser
- Contains all discovered project paths as source_directories
- Contains the selected destination as backup_destination
- Includes appropriate exclude patterns for detected project types
- Round-trip correctly: generate → parse → format → parse produces equivalent config
"""

import tempfile
from pathlib import Path
from typing import List, Set

import pytest
from hypothesis import given, settings, assume, HealthCheck
from hypothesis import strategies as st

from devbackup.config import (
    Configuration,
    format_config,
    parse_config_string,
)
from devbackup.defaults import (
    SmartDefaults,
    SmartDefaultsConfig,
    DefaultsError,
    PROJECT_EXCLUDE_PATTERNS,
    UNIVERSAL_EXCLUDE_PATTERNS,
)
from devbackup.discovery import (
    DiscoveredProject,
    DiscoveredDestination,
)


# Strategy for generating valid directory names (no special chars that break TOML)
dirname_strategy = st.text(
    alphabet=st.sampled_from("abcdefghijklmnopqrstuvwxyz0123456789_"),
    min_size=1,
    max_size=15,
).filter(lambda x: x and not x.startswith("."))

# Strategy for project types
project_type_strategy = st.sampled_from(["python", "node", "rust", "go", "xcode", "generic"])

# Strategy for destination types
destination_type_strategy = st.sampled_from(["external", "network", "icloud", "local"])


def create_discovered_project(
    name: str,
    project_type: str,
    base_path: Path = None,
) -> DiscoveredProject:
    """Create a DiscoveredProject for testing.
    
    Args:
        name: Project name
        project_type: Type of project
        base_path: Base path for the project (defaults to /tmp/projects)
        
    Returns:
        DiscoveredProject object
    """
    if base_path is None:
        base_path = Path("/tmp/projects")
    
    # Get marker files for this project type
    marker_map = {
        "python": ["pyproject.toml"],
        "node": ["package.json"],
        "rust": ["Cargo.toml"],
        "go": ["go.mod"],
        "xcode": [".xcodeproj"],
        "generic": [".git"],
    }
    markers = marker_map.get(project_type, [".git"])
    
    return DiscoveredProject(
        path=base_path / name,
        name=name,
        project_type=project_type,
        estimated_size_bytes=1024 * 1024,  # 1MB default
        marker_files=markers,
    )


def create_discovered_destination(
    name: str,
    dest_type: str,
    base_path: Path = None,
) -> DiscoveredDestination:
    """Create a DiscoveredDestination for testing.
    
    Args:
        name: Destination name
        dest_type: Type of destination
        base_path: Base path for the destination
        
    Returns:
        DiscoveredDestination object
    """
    if base_path is None:
        if dest_type == "external":
            base_path = Path("/Volumes")
        elif dest_type == "icloud":
            base_path = Path.home() / "Library" / "Mobile Documents"
        else:
            base_path = Path.home()
    
    is_removable = dest_type == "external"
    score_map = {"external": 90, "network": 70, "icloud": 50, "local": 30}
    
    return DiscoveredDestination(
        path=base_path / name,
        name=name,
        destination_type=dest_type,
        available_bytes=100 * 1024 * 1024 * 1024,  # 100GB
        total_bytes=500 * 1024 * 1024 * 1024,  # 500GB
        is_removable=is_removable,
        recommendation_score=score_map.get(dest_type, 30),
    )


class TestConfigurationGenerationRoundTripProperty:
    """
    Property 3: Configuration Generation Round-Trip
    
    *For any* set of discovered projects and a selected destination, the 
    configuration generated by SmartDefaults SHALL:
    - Be parseable by the existing Config_Parser
    - Contain all discovered project paths as source_directories
    - Contain the selected destination as backup_destination
    - Include appropriate exclude patterns for detected project types
    - Round-trip correctly: generate → parse → format → parse produces equivalent config
    
    **Validates: Requirements 1.5, 11.1, 11.6**
    """
    
    @given(
        project_configs=st.lists(
            st.tuples(dirname_strategy, project_type_strategy),
            min_size=1,
            max_size=5,
            unique_by=lambda x: x[0],  # Unique names
        ),
        dest_name=dirname_strategy,
        dest_type=destination_type_strategy,
    )
    @settings(
        max_examples=100,
        deadline=None,
        suppress_health_check=[HealthCheck.too_slow],
    )
    def test_generated_config_is_parseable(
        self,
        project_configs: List[tuple],
        dest_name: str,
        dest_type: str,
    ):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Generated configuration SHALL be parseable by the existing Config_Parser.
        
        **Validates: Requirements 1.5, 11.1**
        """
        # Create discovered projects
        projects = [
            create_discovered_project(name, ptype)
            for name, ptype in project_configs
        ]
        
        # Create destination
        destination = create_discovered_destination(dest_name, dest_type)
        
        # Generate configuration
        smart_defaults = SmartDefaults()
        config = smart_defaults.generate_config(projects, destination)
        
        # Format to TOML
        toml_str = format_config(config)
        
        # Parse back - should not raise
        parsed_config = parse_config_string(toml_str)
        
        # Verify it's a valid Configuration object
        assert isinstance(parsed_config, Configuration)
        assert parsed_config.backup_destination is not None
        assert len(parsed_config.source_directories) > 0
    
    @given(
        project_configs=st.lists(
            st.tuples(dirname_strategy, project_type_strategy),
            min_size=1,
            max_size=5,
            unique_by=lambda x: x[0],
        ),
        dest_name=dirname_strategy,
        dest_type=destination_type_strategy,
    )
    @settings(
        max_examples=100,
        deadline=None,
        suppress_health_check=[HealthCheck.too_slow],
    )
    def test_all_project_paths_in_source_directories(
        self,
        project_configs: List[tuple],
        dest_name: str,
        dest_type: str,
    ):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Generated config SHALL contain all discovered project paths as source_directories.
        
        **Validates: Requirements 1.5**
        """
        # Create discovered projects
        projects = [
            create_discovered_project(name, ptype)
            for name, ptype in project_configs
        ]
        
        # Create destination
        destination = create_discovered_destination(dest_name, dest_type)
        
        # Generate configuration
        smart_defaults = SmartDefaults()
        config = smart_defaults.generate_config(projects, destination)
        
        # Verify all project paths are in source_directories
        source_paths = {str(p) for p in config.source_directories}
        for project in projects:
            assert str(project.path) in source_paths, \
                f"Project path {project.path} should be in source_directories"
        
        # Verify count matches
        assert len(config.source_directories) == len(projects), \
            f"Should have {len(projects)} source directories, got {len(config.source_directories)}"
    
    @given(
        project_configs=st.lists(
            st.tuples(dirname_strategy, project_type_strategy),
            min_size=1,
            max_size=3,
            unique_by=lambda x: x[0],
        ),
        dest_name=dirname_strategy,
        dest_type=destination_type_strategy,
    )
    @settings(
        max_examples=100,
        deadline=None,
        suppress_health_check=[HealthCheck.too_slow],
    )
    def test_destination_in_backup_destination(
        self,
        project_configs: List[tuple],
        dest_name: str,
        dest_type: str,
    ):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Generated config SHALL contain the selected destination as backup_destination.
        
        **Validates: Requirements 1.5**
        """
        # Create discovered projects
        projects = [
            create_discovered_project(name, ptype)
            for name, ptype in project_configs
        ]
        
        # Create destination
        destination = create_discovered_destination(dest_name, dest_type)
        
        # Generate configuration
        smart_defaults = SmartDefaults()
        config = smart_defaults.generate_config(projects, destination)
        
        # Verify backup destination is based on the selected destination
        # SmartDefaults adds a "devbackup" subdirectory
        expected_dest = destination.path / "devbackup"
        assert config.backup_destination == expected_dest, \
            f"Backup destination should be {expected_dest}, got {config.backup_destination}"
    
    @given(
        project_type=project_type_strategy,
        dest_name=dirname_strategy,
        dest_type=destination_type_strategy,
    )
    @settings(
        max_examples=100,
        deadline=None,
        suppress_health_check=[HealthCheck.too_slow],
    )
    def test_exclude_patterns_for_project_type(
        self,
        project_type: str,
        dest_name: str,
        dest_type: str,
    ):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Generated config SHALL include appropriate exclude patterns for detected project types.
        
        **Validates: Requirements 1.5**
        """
        # Create a single project of the given type
        project = create_discovered_project("test_project", project_type)
        destination = create_discovered_destination(dest_name, dest_type)
        
        # Generate configuration
        smart_defaults = SmartDefaults()
        config = smart_defaults.generate_config([project], destination)
        
        # Verify universal patterns are included
        for pattern in UNIVERSAL_EXCLUDE_PATTERNS:
            assert pattern in config.exclude_patterns, \
                f"Universal pattern '{pattern}' should be in exclude_patterns"
        
        # Verify project-specific patterns are included
        type_patterns = PROJECT_EXCLUDE_PATTERNS.get(project_type, [])
        for pattern in type_patterns:
            assert pattern in config.exclude_patterns, \
                f"Project-specific pattern '{pattern}' for {project_type} should be in exclude_patterns"
    
    @given(
        project_configs=st.lists(
            st.tuples(dirname_strategy, project_type_strategy),
            min_size=1,
            max_size=5,
            unique_by=lambda x: x[0],
        ),
        dest_name=dirname_strategy,
        dest_type=destination_type_strategy,
    )
    @settings(
        max_examples=100,
        deadline=None,
        suppress_health_check=[HealthCheck.too_slow],
    )
    def test_round_trip_produces_equivalent_config(
        self,
        project_configs: List[tuple],
        dest_name: str,
        dest_type: str,
    ):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Round-trip (generate → format → parse → format → parse) SHALL produce equivalent config.
        
        **Validates: Requirements 1.5, 11.1, 11.6**
        """
        # Create discovered projects
        projects = [
            create_discovered_project(name, ptype)
            for name, ptype in project_configs
        ]
        
        # Create destination
        destination = create_discovered_destination(dest_name, dest_type)
        
        # Generate configuration
        smart_defaults = SmartDefaults()
        original_config = smart_defaults.generate_config(projects, destination)
        
        # First round-trip: format → parse
        toml_str_1 = format_config(original_config)
        parsed_config_1 = parse_config_string(toml_str_1)
        
        # Second round-trip: format → parse
        toml_str_2 = format_config(parsed_config_1)
        parsed_config_2 = parse_config_string(toml_str_2)
        
        # Verify equivalence of key fields
        assert parsed_config_1.backup_destination == parsed_config_2.backup_destination
        assert parsed_config_1.source_directories == parsed_config_2.source_directories
        assert parsed_config_1.exclude_patterns == parsed_config_2.exclude_patterns
        
        # Verify scheduler settings
        assert parsed_config_1.scheduler.type == parsed_config_2.scheduler.type
        assert parsed_config_1.scheduler.interval_seconds == parsed_config_2.scheduler.interval_seconds
        
        # Verify retention settings
        assert parsed_config_1.retention.hourly == parsed_config_2.retention.hourly
        assert parsed_config_1.retention.daily == parsed_config_2.retention.daily
        assert parsed_config_1.retention.weekly == parsed_config_2.retention.weekly
        
        # Verify TOML strings are identical after stabilization
        assert toml_str_1 == toml_str_2, \
            "TOML output should be stable after round-trip"


class TestSmartDefaultsConfiguration:
    """
    Additional tests for SmartDefaults configuration options.
    
    **Validates: Requirements 8.1**
    """
    
    @given(
        interval_seconds=st.integers(min_value=60, max_value=86400),
        retention_hourly=st.integers(min_value=1, max_value=48),
        retention_daily=st.integers(min_value=1, max_value=30),
        retention_weekly=st.integers(min_value=1, max_value=12),
    )
    @settings(
        max_examples=100,
        deadline=None,
        suppress_health_check=[HealthCheck.too_slow],
    )
    def test_custom_defaults_applied(
        self,
        interval_seconds: int,
        retention_hourly: int,
        retention_daily: int,
        retention_weekly: int,
    ):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Custom SmartDefaultsConfig values SHALL be applied to generated config.
        
        **Validates: Requirements 8.1**
        """
        # Create custom defaults config
        custom_config = SmartDefaultsConfig(
            interval_seconds=interval_seconds,
            retention_hourly=retention_hourly,
            retention_daily=retention_daily,
            retention_weekly=retention_weekly,
        )
        
        # Create project and destination
        project = create_discovered_project("test_project", "python")
        destination = create_discovered_destination("TestDrive", "external")
        
        # Generate configuration with custom defaults
        smart_defaults = SmartDefaults(defaults_config=custom_config)
        config = smart_defaults.generate_config([project], destination)
        
        # Verify custom values are applied
        assert config.scheduler.interval_seconds == interval_seconds
        assert config.retention.hourly == retention_hourly
        assert config.retention.daily == retention_daily
        assert config.retention.weekly == retention_weekly
    
    def test_default_hourly_schedule(self):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Default schedule SHALL be hourly (3600 seconds).
        
        **Validates: Requirements 8.1**
        """
        project = create_discovered_project("test_project", "python")
        destination = create_discovered_destination("TestDrive", "external")
        
        smart_defaults = SmartDefaults()
        config = smart_defaults.generate_config([project], destination)
        
        assert config.scheduler.interval_seconds == 3600, \
            "Default schedule should be hourly (3600 seconds)"
        assert config.scheduler.type == "launchd", \
            "Default scheduler type should be launchd"
    
    def test_default_retention_24_7_4(self):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Default retention SHALL be 24 hourly, 7 daily, 4 weekly.
        
        **Validates: Requirements 8.1**
        """
        project = create_discovered_project("test_project", "python")
        destination = create_discovered_destination("TestDrive", "external")
        
        smart_defaults = SmartDefaults()
        config = smart_defaults.generate_config([project], destination)
        
        assert config.retention.hourly == 24, "Default hourly retention should be 24"
        assert config.retention.daily == 7, "Default daily retention should be 7"
        assert config.retention.weekly == 4, "Default weekly retention should be 4"


class TestExcludePatternGeneration:
    """
    Tests for exclude pattern generation based on project types.
    
    **Validates: Requirements 4.3**
    """
    
    @given(
        project_types=st.lists(
            project_type_strategy,
            min_size=1,
            max_size=6,
            unique=True,
        ),
    )
    @settings(
        max_examples=100,
        deadline=None,
        suppress_health_check=[HealthCheck.too_slow],
    )
    def test_combined_patterns_for_multiple_types(
        self,
        project_types: List[str],
    ):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Exclude patterns SHALL combine patterns from all project types.
        
        **Validates: Requirements 4.3**
        """
        smart_defaults = SmartDefaults()
        patterns = smart_defaults.get_exclude_patterns(set(project_types))
        
        # Verify universal patterns are included
        for pattern in UNIVERSAL_EXCLUDE_PATTERNS:
            assert pattern in patterns, \
                f"Universal pattern '{pattern}' should be included"
        
        # Verify patterns from each project type are included
        for ptype in project_types:
            type_patterns = PROJECT_EXCLUDE_PATTERNS.get(ptype, [])
            for pattern in type_patterns:
                assert pattern in patterns, \
                    f"Pattern '{pattern}' for {ptype} should be included"
    
    def test_patterns_are_sorted(self):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Exclude patterns SHALL be returned sorted.
        """
        smart_defaults = SmartDefaults()
        patterns = smart_defaults.get_exclude_patterns({"python", "node", "rust"})
        
        assert patterns == sorted(patterns), \
            "Exclude patterns should be sorted"
    
    def test_patterns_are_unique(self):
        """
        Feature: user-experience-enhancement, Property 3: Configuration Generation Round-Trip
        
        Exclude patterns SHALL not contain duplicates.
        """
        smart_defaults = SmartDefaults()
        patterns = smart_defaults.get_exclude_patterns({"python", "node", "rust", "go", "xcode", "generic"})
        
        assert len(patterns) == len(set(patterns)), \
            "Exclude patterns should not contain duplicates"


class TestErrorHandling:
    """
    Tests for error handling in SmartDefaults.
    """
    
    def test_empty_projects_raises_error(self):
        """
        SmartDefaults SHALL raise DefaultsError when no projects provided.
        """
        destination = create_discovered_destination("TestDrive", "external")
        
        smart_defaults = SmartDefaults()
        
        with pytest.raises(DefaultsError) as exc_info:
            smart_defaults.generate_config([], destination)
        
        assert "No projects provided" in str(exc_info.value)
    
    def test_none_destination_raises_error(self):
        """
        SmartDefaults SHALL raise DefaultsError when destination is None.
        """
        project = create_discovered_project("test_project", "python")
        
        smart_defaults = SmartDefaults()
        
        with pytest.raises(DefaultsError) as exc_info:
            smart_defaults.generate_config([project], None)
        
        assert "No destination provided" in str(exc_info.value)
